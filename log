Flattening the netlist for multiplier_miter...

 /----------------------------------------------------------------------------\
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |  Copyright (C) 2012 - 2024  Claire Xenia Wolf <claire@yosyshq.com>         |
 |  Distributed under an ISC-like license, type "license" to see terms        |
 \----------------------------------------------------------------------------/
 Yosys 0.48+5 (git sha1 7a362f1f7, clang++ 18.1.8 -fPIC -O3)

-- Running command `read -define ASSUME_ON=1' --

-- Executing script file `scripts/flatten_verilog_temp.ys' --

1. Executing Verilog-2005 frontend: verilog/multiplier_miter.sv
Parsing formal SystemVerilog input from `verilog/multiplier_miter.sv' to AST representation.
Generating RTLIL representation for module `\MUL'.
Generating RTLIL representation for module `\top'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.1.1. Analyzing design hierarchy..
Top module:  \top
Used module:     \MUL

2.1.2. Analyzing design hierarchy..
Top module:  \top
Used module:     \MUL
Removed 0 unused modules.
Module top directly or indirectly contains formal properties -> setting "keep" attribute.
Warning: Resizing cell port top.copy2.o from 17 bits to 32 bits.
Warning: Resizing cell port top.copy1.o from 17 bits to 32 bits.

2.2. Executing PROC pass (convert processes to netlists).

2.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

2.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

2.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 13 assignments to connections.

2.2.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\MUL.$proc$verilog/multiplier_miter.sv:0$26'.
  Set init value: \a_reg = 16'0000000000000000
  Set init value: \b_reg = 16'0000000000000000
  Set init value: \o_reg = 0
  Set init value: \busy = 1'0
  Set init value: \finish = 1'0
  Set init value: \counter = 5'00000

2.2.5. Executing PROC_ARST pass (detect async resets in processes).

2.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

2.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\top.$proc$verilog/multiplier_miter.sv:100$35'.
Creating decoders for process `\MUL.$proc$verilog/multiplier_miter.sv:0$26'.
Creating decoders for process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.

2.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).

2.2.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\top.\assume_1_violate' using process `\top.$proc$verilog/multiplier_miter.sv:100$35'.
  created $dff cell `$procdff$46' with positive edge clock.
Creating register for signal `\MUL.\a_reg' using process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.
  created $dff cell `$procdff$47' with positive edge clock.
Creating register for signal `\MUL.\b_reg' using process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.
  created $dff cell `$procdff$48' with positive edge clock.
Creating register for signal `\MUL.\o_reg' using process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.
  created $dff cell `$procdff$49' with positive edge clock.
Creating register for signal `\MUL.\busy' using process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.
  created $dff cell `$procdff$50' with positive edge clock.
Creating register for signal `\MUL.\finish' using process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.
  created $dff cell `$procdff$51' with positive edge clock.
Creating register for signal `\MUL.\counter' using process `\MUL.$proc$verilog/multiplier_miter.sv:36$25'.
  created $dff cell `$procdff$52' with positive edge clock.

2.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `top.$proc$verilog/multiplier_miter.sv:100$35'.
Removing empty process `MUL.$proc$verilog/multiplier_miter.sv:0$26'.
Removing empty process `MUL.$proc$verilog/multiplier_miter.sv:36$25'.
Cleaned up 0 empty switches.

2.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~2 debug messages>
Optimizing module MUL.
<suppressed ~5 debug messages>

2.3. Executing FUTURE pass.

2.4. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
Optimizing module MUL.

2.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Finding unused cells or wires in module \MUL..
Removed 3 unused cells and 28 unused wires.
<suppressed ~5 debug messages>

2.6. Executing CHECK pass (checking for obvious problems).
Checking module MUL...
Checking module top...
Found and reported 0 problems.

2.7. Executing OPT pass (performing simple optimizations).

2.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module MUL.
Optimizing module top.

2.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\MUL'.
<suppressed ~12 debug messages>
Finding identical cells in module `\top'.
Removed a total of 4 cells.

2.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \MUL..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~5 debug messages>

2.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \MUL.
  Optimizing cells in module \top.
Performed a total of 0 changes.

2.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\MUL'.
Finding identical cells in module `\top'.
Removed a total of 0 cells.

2.7.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \MUL..
Finding unused cells or wires in module \top..
Removed 0 unused cells and 4 unused wires.
<suppressed ~1 debug messages>

2.7.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module MUL.
Optimizing module top.

2.7.8. Rerunning OPT passes. (Maybe there is more to do..)

2.7.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \MUL..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~5 debug messages>

2.7.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \MUL.
  Optimizing cells in module \top.
Performed a total of 0 changes.

2.7.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\MUL'.
Finding identical cells in module `\top'.
Removed a total of 0 cells.

2.7.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \MUL..
Finding unused cells or wires in module \top..

2.7.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module MUL.
Optimizing module top.

2.7.14. Finished OPT passes. (There is nothing left to do.)

2.8. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from port B of cell MUL.$add$verilog/multiplier_miter.sv:33$18 ($add).
Removed top 26 bits (of 32) from port Y of cell MUL.$add$verilog/multiplier_miter.sv:33$18 ($add).
Removed top 27 bits (of 32) from mux cell MUL.$ternary$verilog/multiplier_miter.sv:33$19 ($mux).
Removed top 1 bits (of 6) from port Y of cell MUL.$add$verilog/multiplier_miter.sv:33$18 ($add).
Removed top 27 bits (of 32) from wire MUL.$add$verilog/multiplier_miter.sv:33$18_Y.

2.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \MUL..
Finding unused cells or wires in module \top..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

2.10. Executing MEMORY_COLLECT pass (generating $mem cells).

2.11. Executing OPT pass (performing simple optimizations).

2.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module MUL.
Optimizing module top.

2.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\MUL'.
Finding identical cells in module `\top'.
Removed a total of 0 cells.

2.11.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \MUL..
Finding unused cells or wires in module \top..

2.11.4. Finished fast OPT passes.

2.12. Printing statistics.

=== MUL ===

   Number of wires:                 29
   Number of wire bits:            317
   Number of public wires:          18
   Number of public wire bits:     209
   Number of ports:                  6
   Number of port bits:             67
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 23
     $add                            2
     $dff                            6
     $logic_and                      3
     $logic_not                      4
     $logic_or                       2
     $mux                            5
     $shl                            1

=== top ===

   Number of wires:                 25
   Number of wire bits:            130
   Number of public wires:          18
   Number of public wire bits:      95
   Number of ports:                  8
   Number of port bits:             53
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 14
     $assert                         1
     $dff                            1
     $eq                             1
     $eqx                            2
     $logic_and                      1
     $logic_or                       2
     $ne                             1
     $not                            1
     $reduce_and                     1
     $reduce_bool                    1
     MUL                             2

=== design hierarchy ===

   top                               1
     MUL                             2

   Number of wires:                 83
   Number of wire bits:            764
   Number of public wires:          54
   Number of public wire bits:     513
   Number of ports:                 20
   Number of port bits:            187
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 58
     $add                            4
     $assert                         1
     $dff                           13
     $eq                             1
     $eqx                            2
     $logic_and                      7
     $logic_not                      8
     $logic_or                       6
     $mux                           10
     $ne                             1
     $not                            1
     $reduce_and                     1
     $reduce_bool                    1
     $shl                            2

2.13. Executing CHECK pass (checking for obvious problems).
Checking module MUL...
Checking module top...
Found and reported 0 problems.

3. Executing FLATTEN pass (flatten design).
Deleting now unused module MUL.
<suppressed ~2 debug messages>

4. Executing Verilog backend.

4.1. Executing BMUXMAP pass.

4.2. Executing DEMUXMAP pass.
Dumping module `\top'.

Warnings: 2 unique messages, 2 total
End of script. Logfile hash: 9f70622357, CPU: user 0.23s system 0.01s, MEM: 26.53 MB peak
Yosys 0.48+5 (git sha1 7a362f1f7, clang++ 18.1.8 -fPIC -O3)
Time spent: 24% 2x read_verilog (0 sec), 13% 6x opt_expr (0 sec), ...
yosys -D ASSUME_ON=1 -s scripts/flatten_verilog_temp.ys
Adding shortcut signals to multiplier_miter...
Transforming Verilog to AIGER format for multiplier_miter...

 /----------------------------------------------------------------------------\
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |  Copyright (C) 2012 - 2024  Claire Xenia Wolf <claire@yosyshq.com>         |
 |  Distributed under an ISC-like license, type "license" to see terms        |
 \----------------------------------------------------------------------------/
 Yosys 0.48+5 (git sha1 7a362f1f7, clang++ 18.1.8 -fPIC -O3)

-- Executing script file `scripts/verilog_to_aig_temp.ys' --

1. Executing Verilog-2005 frontend: output/multiplier_miter_abc_shortcut_exp/shortcut.sv
Parsing formal SystemVerilog input from `output/multiplier_miter_abc_shortcut_exp/shortcut.sv' to AST representation.
Generating RTLIL representation for module `\top'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.1.1. Analyzing design hierarchy..
Top module:  \top

2.1.2. Analyzing design hierarchy..
Top module:  \top
Removed 0 unused modules.
Module top directly or indirectly contains formal properties -> setting "keep" attribute.

2.2. Executing PROC pass (convert processes to netlists).

2.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:246$25'.
Cleaned up 1 empty switch.

2.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

2.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 1 redundant assignment.
Promoted 38 assignments to connections.

2.2.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:231$125'.
  Set init value: \shortcut.neq_o_reg_copy2 = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:228$124'.
  Set init value: \shortcut.neq_finish_copy2 = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:225$123'.
  Set init value: \shortcut.neq_counter_copy2 = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:222$122'.
  Set init value: \shortcut.neq_busy_copy2 = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:219$121'.
  Set init value: \shortcut.neq_b_reg_copy2 = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:216$120'.
  Set init value: \shortcut.neq_a_reg_copy2 = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:187$119'.
  Set init value: \copy2.o_reg = 0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:175$118'.
  Set init value: \copy2.finish = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:169$117'.
  Set init value: \copy2.counter = 5'00000
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:160$116'.
  Set init value: \copy2.busy = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:154$115'.
  Set init value: \copy2.b_reg = 16'0000000000000000
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:145$114'.
  Set init value: \copy2.a_reg = 16'0000000000000000
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:129$113'.
  Set init value: \copy1.o_reg = 0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:117$112'.
  Set init value: \copy1.finish = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:111$111'.
  Set init value: \copy1.counter = 5'00000
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:102$110'.
  Set init value: \copy1.busy = 1'0
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:96$109'.
  Set init value: \copy1.b_reg = 16'0000000000000000
Found init rule in `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:87$108'.
  Set init value: \copy1.a_reg = 16'0000000000000000

2.2.5. Executing PROC_ARST pass (detect async resets in processes).

2.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

2.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:231$125'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:228$124'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:225$123'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:222$122'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:219$121'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:216$120'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:187$119'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:175$118'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:169$117'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:160$116'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:154$115'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:145$114'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:129$113'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:117$112'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:111$111'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:102$110'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:96$109'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:87$108'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:369$104'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:365$100'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:361$96'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:357$92'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:353$88'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:349$84'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:327$82'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:312$69'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:309$68'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:306$67'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:303$66'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:300$65'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:297$64'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:277$46'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:274$45'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:271$44'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:268$43'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:265$42'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:262$41'.
Creating decoders for process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:246$25'.

2.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).

2.2.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\top.\shortcut.neq_o_reg_copy2' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:369$104'.
  created $dff cell `$procdff$131' with positive edge clock.
Creating register for signal `\top.\shortcut.neq_finish_copy2' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:365$100'.
  created $dff cell `$procdff$132' with positive edge clock.
Creating register for signal `\top.\shortcut.neq_counter_copy2' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:361$96'.
  created $dff cell `$procdff$133' with positive edge clock.
Creating register for signal `\top.\shortcut.neq_busy_copy2' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:357$92'.
  created $dff cell `$procdff$134' with positive edge clock.
Creating register for signal `\top.\shortcut.neq_b_reg_copy2' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:353$88'.
  created $dff cell `$procdff$135' with positive edge clock.
Creating register for signal `\top.\shortcut.neq_a_reg_copy2' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:349$84'.
  created $dff cell `$procdff$136' with positive edge clock.
Creating register for signal `\top.\assume_1_violate' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:327$82'.
  created $dff cell `$procdff$137' with positive edge clock.
Creating register for signal `\top.\copy2.counter' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:312$69'.
  created $dff cell `$procdff$138' with positive edge clock.
Creating register for signal `\top.\copy2.finish' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:309$68'.
  created $dff cell `$procdff$139' with positive edge clock.
Creating register for signal `\top.\copy2.busy' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:306$67'.
  created $dff cell `$procdff$140' with positive edge clock.
Creating register for signal `\top.\copy2.o_reg' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:303$66'.
  created $dff cell `$procdff$141' with positive edge clock.
Creating register for signal `\top.\copy2.b_reg' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:300$65'.
  created $dff cell `$procdff$142' with positive edge clock.
Creating register for signal `\top.\copy2.a_reg' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:297$64'.
  created $dff cell `$procdff$143' with positive edge clock.
Creating register for signal `\top.\copy1.counter' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:277$46'.
  created $dff cell `$procdff$144' with positive edge clock.
Creating register for signal `\top.\copy1.finish' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:274$45'.
  created $dff cell `$procdff$145' with positive edge clock.
Creating register for signal `\top.\copy1.busy' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:271$44'.
  created $dff cell `$procdff$146' with positive edge clock.
Creating register for signal `\top.\copy1.o_reg' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:268$43'.
  created $dff cell `$procdff$147' with positive edge clock.
Creating register for signal `\top.\copy1.b_reg' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:265$42'.
  created $dff cell `$procdff$148' with positive edge clock.
Creating register for signal `\top.\copy1.a_reg' using process `\top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:262$41'.
  created $dff cell `$procdff$149' with positive edge clock.

2.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:231$125'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:228$124'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:225$123'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:222$122'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:219$121'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:216$120'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:187$119'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:175$118'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:169$117'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:160$116'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:154$115'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:145$114'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:129$113'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:117$112'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:111$111'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:102$110'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:96$109'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:87$108'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:369$104'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:365$100'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:361$96'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:357$92'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:353$88'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:349$84'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:327$82'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:312$69'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:309$68'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:306$67'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:303$66'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:300$65'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:297$64'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:277$46'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:274$45'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:271$44'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:268$43'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:265$42'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:262$41'.
Removing empty process `top.$proc$output/multiplier_miter_abc_shortcut_exp/shortcut.sv:246$25'.
Cleaned up 0 empty switches.

2.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~1 debug messages>

2.3. Executing FUTURE pass.

2.4. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

2.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 1 unused cells and 98 unused wires.
<suppressed ~2 debug messages>

2.6. Executing CHECK pass (checking for obvious problems).
Checking module top...
Found and reported 0 problems.

2.7. Executing OPT pass (performing simple optimizations).

2.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

2.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~33 debug messages>
Removed a total of 11 cells.

2.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~22 debug messages>

2.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

2.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

2.7.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 11 unused wires.
<suppressed ~1 debug messages>

2.7.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

2.7.8. Rerunning OPT passes. (Maybe there is more to do..)

2.7.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~22 debug messages>

2.7.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

2.7.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

2.7.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

2.7.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

2.7.14. Finished OPT passes. (There is nothing left to do.)

2.8. Executing WREDUCE pass (reducing word size of cells).

2.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

2.10. Executing MEMORY_COLLECT pass (generating $mem cells).

2.11. Executing OPT pass (performing simple optimizations).

2.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

2.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

2.11.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

2.11.4. Finished fast OPT passes.

2.12. Printing statistics.

=== top ===

   Number of wires:                118
   Number of wire bits:            966
   Number of public wires:          99
   Number of public wire bits:     882
   Number of ports:                  8
   Number of port bits:             53
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 95
     $add                            4
     $and                            6
     $assert                         1
     $dff                           19
     $eq                             1
     $eqx                            2
     $logic_and                     13
     $logic_not                      9
     $logic_or                       6
     $mux                           22
     $ne                             7
     $not                            1
     $reduce_and                     1
     $reduce_or                      1
     $shl                            2

2.13. Executing CHECK pass (checking for obvious problems).
Checking module top...
Found and reported 0 problems.

3. Executing FLATTEN pass (flatten design).

4. Executing MEMORY pass.

4.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

4.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

4.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

4.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

4.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

4.6. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

4.7. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

4.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

4.9. Executing MEMORY_COLLECT pass (generating $mem cells).

4.10. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

5. Executing SETUNDEF pass (replace undef values with defined constants).

6. Executing TECHMAP pass (map to technology primitives).

6.1. Executing Verilog-2005 frontend: /root/yosys/oss-cad-suite/lib/../share/yosys/techmap.v
Parsing Verilog input from `/root/yosys/oss-cad-suite/lib/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu_brent_kung'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

6.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $eqx.
Running "alumacc" on wrapper $extern:wrap:$add:A_SIGNED=0:A_WIDTH=5:B_SIGNED=0:B_WIDTH=1:Y_WIDTH=5:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$add:A_SIGNED=0:A_WIDTH=5:B_SIGNED=0:B_WIDTH=1:Y_WIDTH=5:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$add:A_SIGNED=0:A_WIDTH=5:B_SIGNED=0:B_WIDTH=1:Y_WIDTH=5:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$add:A_SIGNED=0:A_WIDTH=32:B_SIGNED=0:B_WIDTH=32:Y_WIDTH=32:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$add:A_SIGNED=0:A_WIDTH=32:B_SIGNED=0:B_WIDTH=32:Y_WIDTH=32:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$add:A_SIGNED=0:A_WIDTH=32:B_SIGNED=0:B_WIDTH=32:Y_WIDTH=32:394426c56d1a028ba8fdd5469b163e04011def47.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $logic_and.
Using extmapper simplemap for cells of type $logic_or.
Using template $paramod$constmap:4ed0df53d91bc7382ad188fb7506ad2e1f451e20$paramod$5a9c0e617ec487dee3f9f3980f769013716e1075\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shl.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $ne.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $reduce_and.
Using extmapper simplemap for cells of type $dff.
Using template $paramod$672a140277c71df8314410f22acc08d55222c3c7\_90_alu for cells of type $alu.
Using template $paramod$fbc7873bff55778c0b3173955b7e4bce1d9d6834\_90_alu for cells of type $alu.
Using extmapper simplemap for cells of type $xor.
Using template $paramod\_90_lcu_brent_kung\WIDTH=32'00000000000000000000000000000101 for cells of type $lcu.
Using extmapper simplemap for cells of type $pos.
Using template $paramod\_90_lcu_brent_kung\WIDTH=32'00000000000000000000000000100000 for cells of type $lcu.
Using extmapper simplemap for cells of type $or.
No more expansions possible.
<suppressed ~1157 debug messages>

7. Executing ABC pass (technology mapping using ABC).

7.1. Extracting gate netlist of module `\top' to `<abc-temp-dir>/input.blif'..
Extracted 1653 gates and 1853 wires to a netlist network with 198 inputs and 150 outputs.

7.1.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 5 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

7.1.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:     2458
ABC RESULTS:               NOT cells:     2038
ABC RESULTS:        internal signals:     1505
ABC RESULTS:           input signals:      198
ABC RESULTS:          output signals:      150
Removing temp directory.

8. Executing AIGER backend.

End of script. Logfile hash: b2b29fd2ff, CPU: user 0.43s system 0.02s, MEM: 42.49 MB peak
Yosys 0.48+5 (git sha1 7a362f1f7, clang++ 18.1.8 -fPIC -O3)
Time spent: 45% 1x abc (0 sec), 11% 3x read_verilog (0 sec), ...
assume_1_violate 0
copy1.a_reg 0
copy1.a_reg 1
copy1.a_reg 2
copy1.a_reg 3
copy1.a_reg 4
copy1.a_reg 5
copy1.a_reg 6
copy1.a_reg 7
copy1.a_reg 8
copy1.a_reg 9
copy1.a_reg 10
copy1.a_reg 11
copy1.a_reg 12
copy1.a_reg 13
copy1.a_reg 14
copy1.a_reg 15
copy1.b_reg 0
copy1.b_reg 1
copy1.b_reg 2
copy1.b_reg 3
copy1.b_reg 4
copy1.b_reg 5
copy1.b_reg 6
copy1.b_reg 7
copy1.b_reg 8
copy1.b_reg 9
copy1.b_reg 10
copy1.b_reg 11
copy1.b_reg 12
copy1.b_reg 13
copy1.b_reg 14
copy1.b_reg 15
copy1.busy 0
copy1.counter 0
copy1.counter 1
copy1.counter 2
copy1.counter 3
copy1.counter 4
copy1.finish 0
copy1.o_reg 0
copy1.o_reg 1
copy1.o_reg 2
copy1.o_reg 3
copy1.o_reg 4
copy1.o_reg 5
copy1.o_reg 6
copy1.o_reg 7
copy1.o_reg 8
copy1.o_reg 9
copy1.o_reg 10
copy1.o_reg 11
copy1.o_reg 12
copy1.o_reg 13
copy1.o_reg 14
copy1.o_reg 15
copy1.o_reg 16
copy1.o_reg 17
copy1.o_reg 18
copy1.o_reg 19
copy1.o_reg 20
copy1.o_reg 21
copy1.o_reg 22
copy1.o_reg 23
copy1.o_reg 24
copy1.o_reg 25
copy1.o_reg 26
copy1.o_reg 27
copy1.o_reg 28
copy1.o_reg 29
copy1.o_reg 30
copy1.o_reg 31
copy2.a_reg 0
copy2.a_reg 1
copy2.a_reg 2
copy2.a_reg 3
copy2.a_reg 4
copy2.a_reg 5
copy2.a_reg 6
copy2.a_reg 7
copy2.a_reg 8
copy2.a_reg 9
copy2.a_reg 10
copy2.a_reg 11
copy2.a_reg 12
copy2.a_reg 13
copy2.a_reg 14
copy2.a_reg 15
copy2.b_reg 0
copy2.b_reg 1
copy2.b_reg 2
copy2.b_reg 3
copy2.b_reg 4
copy2.b_reg 5
copy2.b_reg 6
copy2.b_reg 7
copy2.b_reg 8
copy2.b_reg 9
copy2.b_reg 10
copy2.b_reg 11
copy2.b_reg 12
copy2.b_reg 13
copy2.b_reg 14
copy2.b_reg 15
copy2.busy 0
copy2.counter 0
copy2.counter 1
copy2.counter 2
copy2.counter 3
copy2.counter 4
copy2.finish 0
copy2.o_reg 0
copy2.o_reg 1
copy2.o_reg 2
copy2.o_reg 3
copy2.o_reg 4
copy2.o_reg 5
copy2.o_reg 6
copy2.o_reg 7
copy2.o_reg 8
copy2.o_reg 9
copy2.o_reg 10
copy2.o_reg 11
copy2.o_reg 12
copy2.o_reg 13
copy2.o_reg 14
copy2.o_reg 15
copy2.o_reg 16
copy2.o_reg 17
copy2.o_reg 18
copy2.o_reg 19
copy2.o_reg 20
copy2.o_reg 21
copy2.o_reg 22
copy2.o_reg 23
copy2.o_reg 24
copy2.o_reg 25
copy2.o_reg 26
copy2.o_reg 27
copy2.o_reg 28
copy2.o_reg 29
copy2.o_reg 30
copy2.o_reg 31
shortcut.neq_a_reg_copy2 0
shortcut.neq_b_reg_copy2 0
shortcut.neq_busy_copy2 0
shortcut.neq_counter_copy2 0
shortcut.neq_finish_copy2 0
shortcut.neq_o_reg_copy2 0
Running ABC with PDR for multiplier_miter...
PDR commands are: read output/multiplier_miter_abc_shortcut_exp/shortcut.aig;
    fold;
    pdr -v -w -d -I output/multiplier_miter_abc_shortcut_exp/shortcut.pla -R output/multiplier_miter_abc_shortcut_exp/shortcut.relation; write_cex -n -m -f output/multiplier_miter_abc_shortcut_exp/shortcut.cex;
Interpreting the PDR log for multiplier_miter...
Counterexample file not found!
-s
Script completed.
